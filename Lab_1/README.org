#+title: Лабораторная работа номер 1. Введение в JavaScript

* Цель работы
Ознакомиться с основами JavaScript, научиться написанию и выполению
кода, изучить базовые конструкции языка.

* Инструкции по запуску проекта
Для запуска проекта, скачайте репозиторий любым удобным методом, и
запустите файл [[file:index.html][=index.html=]].

* Ход работы

** Подготовка среды
*** Установка текстового редактора
Для выполнения работы я использую +текстовый редактор+ универсальный
интерпретатор языка Emacs Lisp с функциями текстового редактора GNU
Emacs, установленный мной через пакетный менеджер GNU Guix. Установка
выполняется при помощи [[https://git.disroot.org/lesikedelweiss/dotfiles][моего конфигурационного файла]] и команды [[https://guix.gnu.org/manual/devel/en/html_node/Invoking-guix-home.html][~guix
home~]].

#+CAPTION: GNU Emacs на моём ПК.
#+NAME: fig:emacs
[[./images/emacs.png]]

*** Установка =Node.js=
Для установки =Node.js= использовалась команда [[https://guix.gnu.org/manual/devel/en/html_node/Invoking-guix-shell.html][~guix shell~]] с
прикреплённым к этой работе файлом манифеста.

#+CAPTION: Установка Node.js.
#+NAME: fig:node
[[./images/shell.png]]


*** Открыть консоль =Devtools= в браузере
Для открытия =Devtools= используется клавиша =F12=, после чего мы
переходим в вкладку =Консоль=. Это крайне удобно, поскольку позволяет
нам работать с кодом через REPL, как в диалектах Lisp, т.е. привычном
для пользователей GNU Emacs образом.

#+CAPTION: Использование консоли в браузере.
#+NAME: fig:console
[[./images/console.png]]

** Выполнение JavaScript кода в браузере
Как уже было обсуждено ранее, JavaScript можно выполнять через REPL в
брузере, что является удобным способом выполнения простого кода, или
тестирования каких либо функций. Воспользуемся этой возможностью, для
выполнения кода! Запишем несколько простых выражений и инструкций в
консоль!

#+CAPTION: Выполнение кода в консоли браузера.
#+NAME: fig:browser_simple_eval
[[./images/browser_simple.png]]

Видно, что первая введённая команда является инструкцией. Ведь так?
Она не возвращает _определенное_ значение (но возвращает undefined), и
имеет побочный эффект (вывод в консоль).

А вторая команда является выражением, поскольку она возвращает
результат.

** Создаем первую HTML-страницу с JavaScript!
После создания файла [[./index.html][=index.html=]] в него был вставлен предложенный код.

#+CAPTION: Создание первого файла!
#+NAME: fig:first_html
[[./images/creating_first.png]]

Запустим же его в браузере!

#+CAPTION: Запуск!
#+NAME: fig:first_html_run
[[./images/creating_first_run.png]]

Ого-го! Вывелось окно с текстом =Привет, мир!= Это следствие
выполнения инструкции ~alert()~.

#+CAPTION: Что-то еще вывелось!
#+NAME: fig:first_html_run_console
[[./images/creating_first_run_2.png]]

Также в консоль вывелся текст =Hello, console!=, что является
следствием выполнения инструкции ~console.log()~.

*** Подключаем внешний JavaScript файл
Создадим файл [[./script.js][=script.js=]] в который поместим предложенный в файле
лабораторной работы код.

#+CAPTION: Создаём внешний файл с кодом
#+NAME: fig:ext_code
[[./images/creating_ext.png]]

Теперь подключим этот файл в [[file:index.html][=index.html=]]. Для этого добавляем тэг
~<script>~. Его можно добавлять в разных местах, но обычно это
делается или в ~<head>~, или в конце ~<body>~. Расположение этого тэга
влияет на то, в какой момент загрузки страницы произойдет выполнение
кода.

#+CAPTION: Подключаем код.
#+NAME: fig:ext_code_con
[[file:images/creating_ext_1.png]]

Выполним полученный код, и пронаблюдаем за результатом

[[file:images/creating_ext_2.png]]
[[file:images/creating_ext_3.png]]
[[file:images/creating_ext_4.png]]

При выполнении замечаем, что сначала исполняются команды из внешнего
файла, а только потом встроенные в код. Это происходит из-за разного
местоположения тэга ~<script>~.

** Работа с типами данных
*** Объявление переменных и работа с типами данных
Объявим в файле [[file:script.js][=script.js=]] переменные разных типов, и выведем их в консоль:

[[file:images/type_1.png]]

Запустим этот код в браузере!

[[file:images/type_2.png]]

Чудо-чудное, диво-дивное! У нас получилось вывести данные, записанные
в переменных, в консоль!

Добавим предложенный в инструктаже код в наш файл.

[[file:images/type_3.png]]

Теперь запустим его в браузере, и проанализируем результаты его
выполнения!

При запуске запросило ввод данных. Это происходит из-за выражения
~prompt()~. Заполним его числом.

[[file:images/type_4.png]]

Вывело текст =Можно лучше!= и пять =Итерация {число}=. Первый текст
был выведен, согласно условиям конструкции if. Поскольку введенный
мной балл был меньше 70.

[[file:images/type_5.png]]

Попбробуем достичь иных возможных результатов.

При введении балла 88 выполнилось условие ~score >=70~, и вывелся
текст =Хорошо=.

[[./images/type_6.png]]
[[./images/type_7.png]]

При введении балла 1337 выполнилось условие ~score >= 90~, и вывелся
текст =Отлично!=.

[[./images/type_8.png]]
[[./images/type_9.png]]

* Отвечаю на контрольные вопросы!

1. 
   + Чем отличаетcя =var= от =let= и =const=?
   + =var= определяет изменяемую переменную с глобальной областью
     видимости, то есть, она будет видна не только внутри блоков =if=
     или =for=, но и за их пределами, а также допускает
     переопределение переменной. =let= лишён фатального недостатка
     =var=, и создаёт изменяемую переменную, область видимости которой
     ограниченна блоком, в котором она определена. =const= же, в свою
     очередь, создаёт неизменяемые переменные.
2. 
   + Что такое неявное преобразование типов в JavaScript?
   + Неявное преобразование типов, это удивительное свойство, присущее
     языкам со слабой типизацией. Оно позволяет языку самостоятельно,
     без явного выражения такого желания программистом,
     приобразовывать переменные из одного типа в другой. Таким образом
     выражение ~"11" + 1~ вернет результат ~"111"~, а ~"11" - 1~
     вернёт ~10~. Причиной этому служит тот факт, что в первом случае,
     JavaScript преобразует число 1 в строку, а во втором случае
     строку "11" в число.
3. 
   + Как работает оператор ​=​= в сравнении с ​=​=​=?
   + Оператор ​=​= сравнивает на равенство значения, и допускает
     приведение типов, а оператор ​=​=​=, не производит приведения типов,
     и сравнивает только идентичные объекты.

* Использованные источники
Программа нашего курса, и материалы с moodle. Вот так вот.
